# უსაფრთხოების სისტემების დოკუმენტაცია

ამ ფაილში აღწერილია პროექტში დამატებული უსაფრთხოების მექანიზმები, მათი დანიშნულება და იმპლემენტაციის დეტალები.

## 1. Brute-Force დაცვა (Rate Limiting)

**პრობლემა**: ბოროტმოქმედმა შეიძლება სცადოს პაროლის გამოცნობა ათასობით კომბინაციის სწრაფად შეყვანით.
**გადაწყვეტა**: დაემატა `express-rate-limit` ბიბლიოთეკა.

### რას აკეთებს სკრიპტი?

- ზღუდავს ავტორიზაციის მცდელობებს ერთი IP მისამართიდან.
- **ლოგიკა**: თუ მომხმარებელი 15 წუთის განმავლობაში 5-ჯერ არასწორად შეიყვანს მონაცემებს, სერვერი დროებით დაბლოკავს მას.

### კოდის ფრაგმენტი (`server.js`):

```javascript
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 წუთი
  max: 5, // მაქსიმუმ 5 ცდა
  message: "Too many login attempts...", // შეტყობინება დაბლოკვისას
});

// გამოყენება ლოგინ როუტზე
app.post("/login", loginLimiter, (req, res) => { ... });
```

---

## 2. Captcha სისტემა (Bot Protection)

**პრობლემა**: ბოტებს შეუძლიათ ავტომატურად გაგზავნონ მოთხოვნები ფორმებზე (სპამი, პაროლის ტეხვა).
**გადაწყვეტა**: დაემატა `svg-captcha` ბიბლიოთეკა.

### რას აკეთებს სკრიპტი?

1.  **გენერაცია**: ქმნის შემთხვევით სურათს (SVG) ასოებით და რიცხვებით.
2.  **შენახვა**: სურათზე გამოსახულ ტექსტს ინახავს სესიაში (`req.session.captcha`).
3.  **ვალიდაცია**: ამოწმებს, ემთხვევა თუ არა მომხმარებლის მიერ შეყვანილი კოდი სესიაში შენახულს.

### კოდის ფრაგმენტი (`server.js`):

```javascript
// Captcha-ს გენერაციის როუტი
app.get("/captcha", (req, res) => {
  const captcha = svgCaptcha.create();
  req.session.captcha = captcha.text; // პასუხის დამახსოვრება
  res.type("svg");
  res.status(200).send(captcha.data); // სურათის გაგზავნა
});

// შემოწმება ლოგინის დროს
if (req.session.captcha !== req.body.captcha) {
  // შეცდომა: კოდი არასწორია
}
```

---

## 3. პაროლების დაცვა (Hashing)

**პრობლემა**: თუ პაროლებს ღია სახით შევინახავთ (მაგ: "secret123"), ჰაკერმა ბაზის მოპარვის შემთხვევაში ყველა პაროლი ეცოდინება.
**გადაწყვეტა**: დაემატა `bcryptjs` ბიბლიოთეკა.

### რას აკეთებს სკრიპტი?

ვიყენებთ **Salted Hashing** მეთოდს.

1.  **არ შეინახოთ პაროლი**: ჩვენ ვინახავთ არა პაროლს, არამედ მის "ანაბეჭდს" (Hash).
2.  **Salt (მარილი)**: პაროლს ემატება შემთხვევითი სიმბოლოები ("მარილი"), რომ ერთი და იგივე პაროლის ჰეში ყოველთვის განსხვავებული იყოს.
3.  **შედარება (`bcrypt.compare`)**: ლოგინის დროს, შეყვანილი პაროლი ისევ ჰეშირდება და სისტემა ადარებს მას ბაზაში შენახულ ჰეშს without ever converting the hash back to the original password (which is mathematically impossible).

### კოდის ფრაგმენტი (`server.js`):

```javascript
// პაროლის ჰეშირება (რეგისტრაციის დროს)
bcrypt.hash("UserPassword123", 10, (err, hash) => {
  // ბაზაში ვინახავთ hash-ს. მაგ: $2a$10$wI...
});

// პაროლის შემოწმება (ლოგინის დროს)
const isMatch = await bcrypt.compare(inputPassword, storedHash);
if (isMatch) {
  // პაროლი სწორია!
}
```

### უპირატესობა

თუ ჰაკერი მოიპარავს `users.json`-ს, ის დაინახავს მხოლოდ გაურკვეველ სტრიქონებს (მაგ: `$2b$10$EixZAYVK1A3...`). მათგან ორიგინალი პაროლის აღდგენა პრაქტიკულად შეუძლებელია.
