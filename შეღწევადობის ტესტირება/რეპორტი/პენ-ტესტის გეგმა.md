# Penetration Testing Project: Presentation Structure (პენ-ტესტინგის პროექტი: პრეზენტაციის გეგმა)

This document outlines the structure for your presentation to the lecturer. It covers the application analysis, vulnerabilities discovered, Python tools used for testing, and the defense mechanisms implemented.

## 1. შესავალი (Introduction)

- **პროექტის მიზანი**: ვებ-აპლიკაციების უსაფრთხოების შესწავლა, სისუსტეების აღმოჩენა და დაცვის მექანიზმების იმპლემენტაცია.
- **ტექნოლოგიები**:
  - **Frontend**: HTML5, CSS3, JavaScript (სიმულაციური ლოგინი).
  - **Backend**: Python (Flask) - Фაილების ატვირთვის სისუსტის სადემონსტრაციოდ.
  - **Tools**: Python Scripts (Selenium, Requests) ავტომატიზებული ტესტირებისთვის.

## 2. აპლიკაციის მიმოხილვა (Application Overview)

### "Login Form" & "Secure App"

- **აღწერა**: ლოგინ ფორმა, რომელიც ახდენს ავტორიზაციის სიმულაციას.
- **ფაილები**: `Secure_App/index.html`, `Secure_App/script.js`.
- **ფუნქციონალი**: მომხმარებლის შეყვანა, პაროლის შემოწმება (Client-Side), Dashboard-ზე გადასვლა.

## 3. სისუსტეები და შეტევები (Vulnerabilities & Attacks)

### 3.1. სუსტი პაროლები (Weak Passwords)

- **პრობლემა**: მომხმარებლები იყენებენ მარტივ პაროლებს ("123456", "password").
- **აღმოჩენა (Python)**:
  - **სკრიპტი**: `hack_test/tester.py`
  - **მეთოდი**: სკრიპტი კითხულობს `passwords.txt` ფაილს და ადარებს მომხმარებლის პაროლებს.
  - **კოდის ფრაგმენტი**:
    ```python
    if password in common_passwords:
        status = "WEAK (Found in DB)"
    ```

### 3.2. SQL Injection (SQL უკუგდება)

- **პრობლემა**: მონაცემთა ბაზასთან არასწორი კომუნიკაცია, რაც საშუალებას იძლევა ავტორიზაციის გვერდის ავლით შესვლას.
- **აღმოჩენა (Python)**:
  - **სკრიპტი**: `Loginform/SQL_Injection_Test/sqli_tester.py`
  - **ტექნოლოგია**: **Selenium WebDriver**.
  - **მოქმედება**: სკრიპტი ავტომატურად უშვებს ბრაუზერს და სათითაოდ ცდის Payload-ებს (`' OR '1'='1`).
  - **შედეგი**: თუ ლოგინი წარმატებულია პაროლის გარეშე, სისუსტე დადასტურებულია.

### 3.3. XSS (Cross-Site Scripting)

- **პრობლემა**: მავნე JavaScript კოდის გაშვება მომხმარებლის ბრაუზერში.
- **აღმოჩენა (Python)**:
  - **სკრიპტი**: `Loginform/XSS_Test/xss_tester.py`
  - **ტექნოლოგია**: **Selenium**.
  - **მოქმედება**: ველში შეჰყავს `<script>alert('XSS')</script>` და ელოდება `Alert` ფანჯარას (`ExpectedConditions.alert_is_present()`).

### 3.4. Keylogger (კლავიატურის ჯაშუში)

- **პრობლემა**: მავნე პროგრამა, რომელიც იწერს მომხმარებლის მიერ აკრეფილ ტექსტს (პაროლებს).
- **დემონსტრაცია**: `hack_test/keylogger_interactive.py`.
- **ფუნქციონალი**: ქმნის ყალბ "ბანკის" გვერდს ტერმინალში და რეალურ დროში აჩვენებს მსხვერპლის აკრეფილ სიმბოლოებს.

### 3.5. ფაილის ატვირთვის სისუსტე (File Upload Vulnerability)

- **პრობლემა**: სერვერი არ ამოწმებს ატვირთული ფაილის ტიპს.
- **კოდი**: `Secure_App/server_vulnerable.py`.
- **საფრთხე**: ჰაკერს შეუძლია ატვირთოს `.py` ან `.php` ფაილი და მოიპოვოს სერვერზე წვდომა (RCE).

## 4. დაცვის მექანიზმები (Defense Mechanisms)

### 4.1. პაროლის პოლიტიკა და დაბლოკვა (Lockout Policy)

- **იმპლემენტაცია**: `Secure_App/script.js`.
- **ლოგიკა**: თუ მომხმარებელი 3-ჯერ არასწორად შეიყვანს პაროლს, სისტემა ბლოკავს მას 1 წუთით (`window.lockoutTime`).
- **ვიზუალი**: "პაროლის სიძლიერის" ინდიკატორი (წითელი/ყვითელი/მწვანე ზოლი).

### 4.2. SQL Injection-ისგან დაცვა

- **იმპლემენტაცია**: `Loginform/Security_Defense/2_Anti_SQL_Injection/secure_db.py`.
- **მეთოდი**: **Parameterized Queries** (პ პარამეტრიზებული მოთხოვნები).
- **ახსნა**: მონაცემები გადაეცემა როგორც პარამეტრები (`?` ნიშნებით) და არა პირდაპირ სტრიქონში, რაც ბლოკავს კოდის შესრულებას.

### 4.3. XSS-ისგან დაცვა

- **იმპლემენტაცია**: `Secure_App/index.html`.
- **მეთოდი**: **CSP (Content Security Policy)** ჰედერი.
- **კოდი**: `<meta http-equiv="Content-Security-Policy" content="...">`.
- **შედეგი**: ბრაუზერი არ უშვებს გარედან შემოტანილ ან "Inline" სკრიპტებს.

## 5. დასკვნა (Conclusion)

- პროექტმა აჩვენა, რომ მხოლოდ ლამაზი ინტერფეისი არ არის საკმარისი; აუცილებელია Backend-ის დაცვა.
- Python-ის სკრიპტები (Selenium, Requests) მძლავრი იარაღია როგორც ჰაკერებისთვის, ასევე ტესტერებისთვის სისუსტეების აღმოსაჩენად.
