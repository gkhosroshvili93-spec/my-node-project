# პენ-ტესტინგის პროექტის პრეზენტაცია

**თემა:** ვებ-უსაფრთხოების ანალიტიკა: შეტევა და დაცვა
**ავტორი:** გიორგი ხოსროშვილი



##  შესავალი 

წარმოგიდგენთ ჩემს პროექტს, რომლის მიზანიც იყო ჩემს მიერ შექმნილი ვებ-პროექტის უსაფრთხოების სიღრმისეული ტესტი. 
მე შევქმენი node.js პროექტი,მესენჯერის,მომხმარებლების ავტორიზაციის და შესვლის ფუნქციებით, სადაც პრაქტიკულად განვახორციელე როგორც **კიბერ-შეტევები**, ასევე **დაცვითი მექანიზმები** 

პროექტი შედგება სამი მთავარი ნაწილისგან:

1.  **სამიზნე აპლიკაცია**:  ვებ-გვერდი (Login Form) და messenger,რაზეც წვდომა ექნებოდა მხოლოდ რეგისტრირებულ მომხმარებლებს.
2.  **შეტევის ინსტრუმენტები**: Python-ზე დაწერილი სკრიპტები სისუსტეების აღმოსაჩენად.
3.  **დაცვა**: node.js მოდულით სერვერის აწყობა,გამოსწორებული სისუსტეები,ჰეშირება,შიფრაცია,2fa და ა.შ



##  აპლიკაციის მიმოხილვა

ბოლო ვერსია:
  **Secure App (დაცული)**: სადაც ყველა ხარვეზი გამოსწორებულია.

**ტექნოლოგიები:**

 **Frontend**: HTML5, CSS, JavaScript.
 **Back-End **: Python Flask,sentinel,jinja და node.js სერვერისთვის.



##  სისუსტეები და მათი აღმოჩენა (Attacks & Python Tools)

პაროლის პროტოკოლი

###  სუსტი პაროლები (Weak Passwords) არ დავუშვი

 მაგ: "123456", "password"


გამორიცხულია
 **მეთოდი:** Dictionary Attack (ლექსიკონური შეტევა).
 **ლოგიკა:** სკრიპტი კითხულობს `passwords.txt` ფაილს და ადარებს მას მომხმარებლის პაროლს.



python
def load_common_passwords(filepath):
    with open(filepath, 'r') as f:
        return set(line.strip() for line in f)

 შემოწმება
if password in common_passwords:
    print("STATUS: WEAK (Found in DB)")


დაცულია
###  SQL Injection (SQL ის ინექცია)

**პრობლემა:** ეს არის ყველაზე კრიტიკული სისუსტე. ნებისმეირ ჰაკერს შეუძლია მანიპულაცია გაუკეთოს მონაცემთა ბაზის მოთხოვნას და შევიდეს სისტემაში პაროლის გარეშე.

**(Python Script):**
გამოვიყენე `Loginform/SQL_Injection_Test/sqli_tester`.

- **ტექნოლოგია:** **Selenium WebDriver**.
- **მეთოდი:** ავტომატიზებული ფაზინგი (Fuzzing). სკრიპტი ავტომატურად უშვებს Chrome ბრაუზერს და სათითაოდ ცდის სპეციალურ სიმბოლოებს (`' OR '1'='1`).

**კოდის ფრაგმენტი (`sqli_tester`):**

python
payloads = ["' OR '1'='1", "admin' --"]

for payload in payloads:
    user_field.send_keys(payload) # შეყავს მავნე კოდი
    login_btn.click()             # აჭერს ღილაკს

    # ამოწმებს შედეგს
    if "ავტორიზაცია წარმატებულია" in driver.page_source:
        print(f"CRITICAL: Bypassed login with {payload}")


Selenium-ის `find_element` და `send_keys` მეთოდებით რეალური ჰაკერის ქმედებების იმიტაცია.

###  XSS 


**გამოირიცხა პრობლემა:** ვებ-გვერდი არ ფილტრავს მომხმარებლის მიერ შეყვანილ ტექსტს. ჰაკერს შეუძლია ჩასვას javascript კოდი (მაგ: `<script>alert(1)</script>`), რომელიც შესრულდება სხვა მომხმარებლის ბრაუზერში.

**როგორ აღმოვაჩინეთ (Python Script):**
გამოვიყენეთ `Loginform/XSS_Test/xss_tester.py`.

 **ტექნოლოგია:** **Selenium WebDriver** + **Alert Handling**.
 **მეთოდი:** სკრიპტი ცდილობს ჩასვას JS კოდი და ელოდება "Alert" ფანჯარას.

**კოდის ფრაგმენტი (`xss_tester`):**

python
try:
    # ველოდები Alert ფანჯარას
    alert = driver.switch_to.alert
    print(f"XSS Triggered! Alert text: {alert.text}")
    alert.accept()
except NoAlertPresentException:
    print("Safe.")


თუ `driver.switch_to.alert` ვერ შესრულდა, ეს ნიშნავს რომ ბრაუზერმა არ გაუშვა მავნე კოდია,შესაბამისად საიტი დაცულია


###  Keylogger (კლავიატურის ჯაშუში)

**პრობლემა:** მავნე პროგრამა, რომელიც ჩუმად იწერს ყველაფერს, რასაც მომხმარებელი კრეფს,ჩვენს ფორმაში ვერ ასრულებს შედეგს.
**დემონსტრაცია:** არ ვასახელებ




###  ფაილის ატვირთვის სისუსტე (File Upload Vulnerability)

**გამოსწორებული პრობლემა:** სერვერი (`Secure_App/server_vulnerable.py`) ამოწმებს ატვირთული ფაილის გაფართოებას.



file = request.files['file']
file.save(os.path.join(UPLOAD_FOLDER, file.filename))


აქ არ არის შემოწმება. ჰაკერს შეუძლია ატვირთოს `hack.py` ან `shell.php` და მოიპოვოს სრული კონტროლი სერვერზე.
მაგრამ ფაილის ატვირთვის ზომა ლიმიტირებულია,ისევე როგორც გაფართოება,გამორიცხულია ყველა bat და exe გაფართოების ფაილის ატვირთვა


## . დაცვის მექანიზმები (Defense)

 პროექტში ჩავაშენე შემდეგი მექანიზმები:

###  SQL Injection-ისგან დაცვა (Parameterized Queries)

 **პარამეტრებს**.

**კოდი (`secure_db.py`):**

python
# სწორი მიდგომა:
sql = "SELECT * FROM users WHERE username = ? AND password = ?"
cursor.execute(sql, (username, password))


ამ შემთხვევაში, ბაზა სიმბოლო `'`-ს აღიქვამს როგორც უბრალო ტექსტს და არა როგორც ბრძანების ნაწილს.

###  XSS-ისგან დაცვა (CSP - Content Security Policy)

**გამოსავალი:** ბრაუზერს უნდა ავუკრძალოთ უცნობი სკრიპტების გაშვება.
**იმპლემენტაცია:** `index.html`-ის ჰედერი.

**კოდი (`index.html`):**

html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self';"
/>


ეს კოდი ეუბნება ბრაუზერს: "გაუშვი მხოლოდ ის სკრიპტები, რომლებიც ჩემს სერვერზეა (`self`). არ გაუშვა არაფერი სხვა."_

### 4.3. Brute Force-ისგან დაცვა (Lockout Policy)

**გამოსავალი:** თუ ვინმე ბევრჯერ ცდება პაროლს, უნდა დავბლოკოთ დროებით.
**იმპლემენტაცია:** `Secure_App/script.js`.

**კოდი (`script.js`):**

javascript
if (loginAttempts[username] >= 3) {
  // ბლოკავს მომხმარებელს 60 წამით
  window.lockoutTime[username] = Date.now() + 60000;
  showMessage("ზედიზედ 3 შეცდომა. დაბლოკილი ხართ 1 წუთით!");
}



## 5. დასკვნა

ამ პროექტმა გვაჩვენა, რომ უსაფრთხოება არ არის "ერთი ღილაკი". ეს არის კომპლექსური პროცესი, რომელიც მოიცავს:

1.  **Code Review** (კოდის შემოწმებას).
2.  **Automated Testing** (Python/Selenium სკრიპტებით ტესტირებას).
3.  **Secure Coding** (დაცული კოდის წერის პრინციპებს).


